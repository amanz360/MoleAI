import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import bwapi.Game;
import bwapi.Player;
import bwapi.TilePosition;
import bwapi.Unit;
import bwapi.UnitType;

public class BuildingManager 
{
	private LinkedList<Building> buildingQueue;
	
	public BuildingManager()
	{
		buildingQueue = new LinkedList<Building>();
	}
	
	public void update(Game game, Player self)
	{
		validateBuildings();					// check to see if assigned workers have died en route or while constructing
		assignWorkersToUnassignedBuildings();   // assign workers to the unassigned buildings and label them 'planned'    
	    constructAssignedBuildings(game);       // for each planned building, if the worker isn't constructing, send the command    
	    checkForStartedConstruction(self);      // check to see if any buildings have started construction and update data structures    
	    checkForDeadTerranBuilders();           // if we are terran and a building is under construction without a worker, assign a new one    
	    checkForCompletedBuildings();           // check to see if any buildings have completed and update data structures
	}
	
	public void validateBuildings()
	{
		ArrayList<Building> buildingsToRemove = new ArrayList<Building>();

		for(Building b : buildingQueue)
		{
			if(b.status != Information.BuildingStatus.UNDERCONSTRUCTION)
			{
				continue;
			}
			
			if(b.buildingUnit == null || !b.buildingUnit.getType().isBuilding() || b.buildingUnit.getHitPoints() <= 0)
			{
				buildingsToRemove.add(b);
			}
		}
				
		buildingQueue.removeAll(buildingsToRemove);
	}
	
	public void assignWorkersToUnassignedBuildings()
	{
		for(Building b : buildingQueue)
		{
			if(b.status != Information.BuildingStatus.UNASSIGNED)
			{
				continue;
			}
			
			MoleUnit workerToAssign = getBuilder(b);
			
			if(workerToAssign != null)
			{
				System.out.println("Assigning worker to building type: " + b.type.toString());
				b.builderUnit = workerToAssign;
				b.status = Information.BuildingStatus.ASSIGNED;
			}
			else
			{
				System.out.println("Error selecting builder");
			}
		}
	}
	
	public void constructAssignedBuildings(Game game)
	{
		for(Building b : buildingQueue)
		{
			if(b.status != Information.BuildingStatus.ASSIGNED)
			{
				continue;
			}
			
			if(!b.builderUnit.myUnit.isConstructing())
			{
				if(b.buildCommandGiven)
				{
					System.out.println("Retrying construction: " + b.type.toString());
					b.builderUnit = null;
					b.buildCommandGiven = false;
					b.status = Information.BuildingStatus.UNASSIGNED;
				}
				else
				{
					System.out.println("Worker ordered to construct: " + b.type.toString());
					TilePosition buildLocation = (b.desiredPosition != null) ? b.desiredPosition : game.getBuildLocation(b.type, b.builderUnit.getTilePosition());
					b.builderUnit.myUnit.build(b.type, buildLocation);
					b.finalPosition = buildLocation;
					b.buildCommandGiven = true;
				}
			}
		}
	}
	
	void checkForStartedConstruction(Player self)
	{
		for(Unit buildingStarted : self.getUnits())
		{
			if(!buildingStarted.getType().isBuilding() || !buildingStarted.isBeingConstructed())
			{
				continue;
			}
			
			for(Building b : buildingQueue)
			{
				if(b.status != Information.BuildingStatus.ASSIGNED)
				{
					continue;
				}
				
				if(b.finalPosition == buildingStarted.getTilePosition())
				{
					System.out.println("Building is under construction: " + b.type.toString());
					b.underConstruction = true;
					b.buildingUnit = buildingStarted;
					b.status = Information.BuildingStatus.UNDERCONSTRUCTION;
					break;
				}
			}
		}
	}
	
	void checkForDeadTerranBuilders()
	{
		for(Building b : buildingQueue)
		{
			if(b.status != Information.BuildingStatus.UNDERCONSTRUCTION)
			{
				continue;
			}
			
			if(!b.builderUnit.exists())
			{
				Unit replacement = getBuilder(b);
				if(replacement != null)
				{
					System.out.println("Replacing dead builder");
					b.builderUnit = replacement;
					b.status = Information.BuildingStatus.ASSIGNED;
					replacement.rightClick(b.finalPosition.toPosition());
				}
			}
		}
	}
	
	void checkForCompletedBuildings()
	{
		ArrayList<Building> toRemove = new ArrayList<Building>();
		
		for(Building b : buildingQueue)
		{
			if(b.status != Information.BuildingStatus.UNDERCONSTRUCTION)
			{
				continue;
			}
			
			if(b.buildingUnit.isCompleted())
			{
				System.out.println("Building completed: " + b.type.toString());
				toRemove.add(b);
			}
		}
		
		buildingQueue.removeAll(toRemove);
	}
	
	public boolean isQueued(UnitType buildingType)
	{
		for(Building b : buildingQueue)
		{
			if(b.type.toString().equals(buildingType.toString()))
			{
				return true;
			}
		}
		
		return false;
	}
	
	public void addBuildingTask(UnitType buildingType, TilePosition location, Unit builder)
	{
		Building newBuilding = new Building(buildingType);
		newBuilding.desiredPosition = location;
		newBuilding.builderUnit = builder;
		newBuilding.status = Information.BuildingStatus.ASSIGNED;
		buildingQueue.add(newBuilding);
	}
	
	public void addBuildingTask(UnitType buildingType, Base b)
	{
		Building newBuilding = new Building(buildingType);
		newBuilding.base = b;
		newBuilding.status = Information.BuildingStatus.UNASSIGNED;
		buildingQueue.add(newBuilding);
		System.out.println("Unassigned building added to queue: " + buildingType);
	}
	
	public MoleUnit getBuilder(Building b)
	{
		System.out.println("Choosing builder");
		if(b.base != null)
		{
			List<MoleUnit> workers = b.base.getAllUnitsByType(Information.UnitType.WORKER);
			for(MoleUnit worker : workers)
			{
				if(worker.job == Information.Job.MINERALS)
				{
					worker.job = Information.Job.CONSTRUCTION;
					System.out.println("Returning builder: " + worker.myUnit);
					return worker;
				}
			}
		}
		
		/*for(Unit builder : builders)
		{
			if(builder.isCompleted() && builder.canBuild(b.type) && !builder.isConstructing())
			{
				myBuilder = builder;
			}
		}*/
		
		return null;
	}
}
